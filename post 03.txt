I did say that the three functions I came up with for the last example was just some random idea. But I liked it. I became intrigued by it. So I'm going to take a short digression to talk about it.

The quickest way to end the loop is CACACA and then A or C: [0, 1, 4, 5, 16, 21, 64, 95, 159 or 286]. Collatzing gives you the biggest number from an odd number. Adding gives you the biggest number from an even number (generally), and if the next-to-last number was odd it gives you an odd number to Collatz.

The biggest number you can get is obviously to Collatz 99 to get 298. There are three shortest ways to do that:

[output][0, 1, 4, 5, 16, 21, 23, 44, 22, 66, 33, 99, 298]
[0, 1, 4, 5,  9, 11, 20, 23, 43, 66, 33, 99, 298]
[0, 1, 4, 5,  7, 11, 18,  9, 27, 36, 63, 99, 298][/output]

I find it interesting that they all start the same. Since there are three of them and three functions, that means that once you get to [0, 1, 4, 5], no matter what you do at that point you can still get to the shortest maximum. Even more interesting is that the first two end the same. So they split on different paths, and then come back to the same one to finish.

As far as I can tell, there are only 307 pairs of numbers that you can get to. And yet there is a huge number of possible sequences, even if you reject loops (or terminate on a loop). Obviously, if you don't reject loops, there's an infinite number of sequences. I tried calculating them all with Python. After ten minutes the first several digits hadn't changed, so I gave up.

In all of those 307 pairs, the numbers 62 and 74 do not show up at all. I'm assuming that's because of the limit at 100. If you increased that, perhaps you could get to 124, and then Collatz back down to 62. But that makes wonder: for each terminal number t, how many numbers from 0 to t are missing, and what numbers are they?

The 307 pairs are the nodes in the graph, or as I call it, the integer graph. We have integer sequences. There's a whole encyclopedia of them online. Why can't we have integer graphs? We can generalize this idea of an integer graph. Didn't I show you that generalizing the menu function was a good idea? Therefore generalizing the idea of an integer graph is a good idea. So, an integer graph is a graph where the nodes are integer tuples of length n, starting with a specific tuple (tranditionally (0, 1, ..., n-1), but it may be different.). Each edge leading from a tuple node is associated with one or more of m sequence functions (f1, f2, ..., fm) that take the tuple (x1, x2, ..., xn) as an input, and return a new tuple (x2, x3, ..., xn+1), with xn+1 being a new number generated by the function. Finally, each integer graph has a terminal number t such that any node containing a number greater than or equal to t has no edges leading from it (t is traditionally 108. Yeah, I know I used 100 the first time, but 108 is a much cooler number. t can be infinity if you really want.) Each integer graph gives rise to a set of integer sequences, being paths through the graph from the initial node to a terminal node or a loop.

I now return you to your regularly scheduled tutorial.